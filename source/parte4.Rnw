\documentclass[compress,serif]{beamer}  % t per mettere al top delle slide
%\documentclass[compress,serif,handout]{beamer} 
%%% Dichiarazione dei pacchetti standard.
\usepackage[italian]{babel}
\usepackage{tikz}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{bm}
\usetikzlibrary{bayesnet}

\definecolor{aqua}{cmyk}{11,17,0,0}
\definecolor{jap}{rgb}{.247,.549,1}
\definecolor{mygreen}{RGB}{34,139,34}
\definecolor{verdeoutput}{rgb}{0,0.533,0.298}
\definecolor{rossooutput}{rgb}{0.6,0,0}
\definecolor{grigiooutput}{RGB}{232,239,239}

%%% Personalizzazione del layout---articolata su cinque livelli.
\usetheme{Frankfurt}        % layout complessivo.
\usefonttheme{structurebold}
%%%% page number
\setbeamertemplate{footline}[frame number]
\setbeamerfont{footline}{size=\scriptsize, series=\bfseries}
\setbeamercolor{footline}{fg = black, bg = black}
\setbeamercolor{page number in head/foot}{fg = gray}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usecolortheme[named=mygreen]{structure}
\setbeamercolor{palette primary}{bg=mygreen,fg=white}
\setbeamercolor{palette secondary}{bg=mygreen,fg=white}
\setbeamercolor{palette tertiary}{bg=white,fg=mygreen}
\setbeamercolor{palette quaternary}{fg=white,bg=mygreen}

\setbeamercolor{title}{fg=white,bg=mygreen}
\setbeamercolor{structure}{fg=green!15!black}
\setbeamercolor{upesempio}{fg=white, bg=orange}
\setbeamercolor{loesempio}{fg=black, bg=green!10!white}%{fg=black, bg=white}
\setbeamercolor{upnotabene}{fg=white, bg=rossooutput}
\setbeamercolor{lonotabene}{fg=red!70!black, bg=yellow!20!white}
\setbeamercolor{uppercolor}{fg=black,bg=green!45!white}
\setbeamercolor{lowercolor}{fg=black, bg=green!25!white}
\setbeamercolor{formula}{fg=black, bg=grigiooutput}

\setbeamercolor{tabelle}{fg=black,bg=green!45!white}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(fig.width=3, fig.height=3,dev="tikz",fig.align='center',echo=FALSE,results="hide",comment=NA,prompt=FALSE,cache=TRUE,external = FALSE)
opts_knit$set(out.format = "latex") #,width=30)
thm = knit_theme$get("autumn")  # approved by lptrainer
knit_theme$set(thm)
@

<<echo=FALSE,message=FALSE>>=
rm(list=ls())
main <- "~/didattica/Bertinoro/"
if (grepl("kolmogorov",Sys.info()["user"])) main <- gsub("~/","~/MEGAsync/",main)
if (grepl("cox",Sys.info()["user"])) main <- gsub("~/","~/MEGA/",main)
datadir <- paste(main,"data/",sep="")
Sdir <- paste(main,"Scodes/",sep="")

esegui <- FALSE
# KUtils::pulizia(paste(main,"knitr/",sep=""), c(".Rnw",".bib"))
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Titolo e autore.
\title{\textbf{4. Introduzione a Stan}}
%\subtitle{\footnotesize{Analisi dei dati in ambito di comunità - AA 2013/14}}
\author{\textbf{Massimiliano Pastore}\\
   Università di Padova}
\date{}

\begin{document}

\begin{frame}[plain]
  \titlepage
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Contents}
  \tableofcontents
\end{frame}

<<functions>>=
### likelihood binomiale 
Lbinom <- function(theta,x,n) {
  y <- dbinom(x,n,theta)/choose(n,x)
  return(y)
}
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[STAN]{Introduction to STAN}
\begin{frame}[plain]
  
  \begin{beamercolorbox}[rounded=true, shadow=true]{tabelle}
\begin{center}
\vspace{-.3cm}
\Large{\textbf{Introduction to STAN}} 
\end{center}
\end{beamercolorbox}

\end{frame}

%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Popularity of Bayesian inference\footnote{\tiny{Lee, M. D., \& Wagenmakers, E. J. (2014). \emph{Bayesian cognitive modeling: A practical course}. Cambridge University Press.}}}

\begin{center}
\scalebox{.4}{\includegraphics{img/BUGS.png}}
\end{center}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Historical background}
  
  \begin{enumerate}
   \item BUGS: \textbf{B}ayesian inference \textbf{U}nder \textbf{G}ibbs \textbf{S}ampling (Gilks et. al., 1994\footnote{\tiny{Gilks, W.R., Thomas, A., Spiegelhalter, D.J. (1994). A language and program for complex Bayesian modelling. \emph{The Statistician}, 43,169-177.}}) 
   \begin{itemize}
   \item Versions: WinBUGS (for Windows), OpenBUGS (mainly for Windows) 
   \item $\mathrm{R}$ packages: \texttt{R2WinBUGS}, \texttt{BRugs}
   \end{itemize}
   \item JAGS: \textbf{J}ust \textbf{A}nother \textbf{G}ibbs \textbf{S}ampler (Plummer, 2015\footnote{\tiny{Plummer, M. (2015) rjags: Bayesian graphical models using MCMC. R package version 3-15. URL: http://cran.r-project.org/package=rjags}}(multiplatform).
   \begin{itemize}
   \item $\mathrm{R}$ packages: \texttt{R2jags}, \texttt{rjags}. 
  \end{itemize}
  \item STAN (Stan Development Team, 2015)
   \begin{itemize}
   \item $\mathrm{R}$ packages: \texttt{rstan}, \texttt{rstanarm}, \texttt{brms}, \texttt{bayesplot}. 
  \end{itemize}

  \end{enumerate}
  
\end{frame}

%%%%%%%%%%%%%%%
\begin{frame}{\textbf{Why STAN?}}

\begin{itemize}
 \item The name is derived from Stanislaw Ulam, coinventor of Monte Carlo Methods.
 \item Stan facilitates Bayesian inference with a modeling
language and state-of-the-art computational methods.
 \item Stan interfaces with the most popular data analysis languages (R, Python, shell, MATLAB, Julia, Stata) and runs on all major platforms (Linux, Mac, Windows).
\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{}
\begin{frame}{\textbf{STAN modeling language}}

\begin{itemize}
 \item A Stan program defines a statistical model through a conditional probability function $p(\theta|y,x)$, where $\theta$ is a sequence of modeled unknown values (e.g., model parameters, latent variables, missing data, future predictions), $y$ is a sequence of modeled known values, and $x$ is a sequence of unmodeled predictors and constants (e.g., sizes, hyperparameters).
 \item Stan programs consist of variable type declarations and statements.
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[basi]{The Binomial model}
\begin{frame}[fragile]{Binomial model}
  
<<>>=
y <- c(rep(1,11),0,0,0)
@
\begin{itemize}
 \item Let us suppose that we want to estimate the accuracy of a subject in a task consisting of \Sexpr{length(y)} trials.
 \item We indicate with 1 the correct response and observe the following result:
<<>>=
cat(sample(y),"\n")
@
i.e.  \Sexpr{sum(y)} correct and \Sexpr{sum(y==0)} wrong answers. 
 
 \item We can then define a likelihood function related to this observed result. 
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Binomial model}

<<>>=
library(ggplot2)
theme_set(theme_bw())
TEMA <- theme(plot.title = element_text(hjust = .5))
## likelihood binomial
Lbinom <- function(theta,x,n) {
  y <- dbinom(x,n,theta)/choose(n,x)
  return(y)
}
d <- data.frame(x=0:1,y=0:1)
@

<<fig.width=4>>=
library(cowplot)
theme_set(theme_bw())
plot_grid(
  ggplot(d,aes(x,y))+stat_function(fun=dbeta,args = list(shape1=1,shape2=1))+xlab("$\\theta$")+ylab("$p(\\theta)$")+ggtitle("prior")+TEMA, 
  ggplot(d,aes(x,y))+stat_function(fun=Lbinom,args=list(x=sum(y),n=length(y)))+xlab("$\\theta$")+ylab("$p(D|\\theta)$")+ggtitle("likelihood")+TEMA
)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Binomial model: STAN code}

<<>>=
binomial_stancode <- "
  // The input data is a vector 'y' of length 'N'.
  data {
    int<lower=0> N;
    array[N] int<lower=0, upper=1> y;
  }
  
  // The parameters accepted by the model. 
  // Our model accepts one parameter 'theta'.
  parameters {
    real<lower=0, upper=1> theta;
  }
  
  // The model to be estimated. We model the output
  // 'y' to be bernoulli distributed with parameter 'theta'.
  model {
    target += bernoulli_lpmf( y | theta );
  }
"
@


<<results='markup'>>=
L <- capture.output( cat(binomial_stancode,"\n") )
L <- L[!grepl("//",L)]

fine <- grep("par",L)-2
for (l in 1:fine) cat(L[l],"\n")
@
\pause \vspace{-.8cm}
<<results='markup'>>=
ini <- fine+1
fine <- grep("model",L)-2
for (l in ini:fine) cat(L[l],"\n")
@
\pause \vspace{-.8cm}
<<results='markup'>>=
ini <- fine+1
for (l in ini:length(L)) cat(L[l],"\n")
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]%{Binomial model: STAN code}

<<echo=TRUE>>=
Scode <- "
  data {
    int<lower=0> N;
    array[N] int<lower=0, upper=1> y;
  }
  parameters {
    real<lower=0, upper=1> theta;
  }
  model {
    target += bernoulli_lpmf( y | theta );
  }
"
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{rstan}
\begin{frame}[fragile]{\texttt{rstan}}

<<message=FALSE>>=
library(rstan)
dataList <- list( y = y, N = length(y) )
SEED <- 1
if (esegui) {
  fit_binomial.1 <- stan( model_code = Scode, data = dataList, seed = SEED, cores = parallel::detectCores() )
  save(fit_binomial.1, SEED, file = paste0(datadir,"STANfit.rda"))
} else {
  load(paste0(datadir,"STANfit.rda"))
}

@

<<eval=FALSE,echo=TRUE>>=
# carico il pacchetto
library(rstan)
@

\pause{}
<<results='markup'>>=
cat("# lista dei dati ","\n")
cat("dataList <- list( ","\n")
cat("   y = c(",paste(y,collapse = ", "),"), ","\n")
cat("   N =",length(y),")","\n")
@

\pause{}
<<echo=TRUE,eval=FALSE>>=
# fit del modello
fit_binomial.1 <- stan( 
  model_code = Scode, 
  data = dataList, 
  seed = 1, 
  cores = parallel::detectCores() 
)
@


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}}
  
%\small
<<echo=TRUE,eval=FALSE>>=
fit_binomial.1
@
\pause %\vspace{-.8cm}
<<results='markup'>>=
options(width = 80)
L <- capture.output(fit_binomial.1)
for (l in 1:4) cat(L[l],"\n")
round(summary(fit_binomial.1,probs=c(.055,.945))$summary,3)
for (l in (grep("Samples",L)-1):length(L)) cat(L[l],"\n")
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{traceplot}}
<<echo=TRUE,message=FALSE,eval=FALSE>>=
stan_trace( fit_binomial.1, inc_warmup = TRUE )
@
\pause
<<fig.height=2.8,fig.width=4.5>>= 
stan_trace( fit_binomial.1, inc_warmup = TRUE )+theme(text=element_text(size=10))
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
plot( fit_binomial.1 )
@

\pause
<<message=FALSE,fig.height=2.5>>=
plot( fit_binomial.1 )
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
plot( fit_binomial.1, plotfun = "hist" )
@
\pause
<<message=FALSE,fig.height=2.5>>=
plot( fit_binomial.1, plotfun = "hist" )
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
plot( fit_binomial.1, plotfun = "dens" )
@
\pause
<<message=FALSE,fig.height=2.5>>=
plot( fit_binomial.1, plotfun = "dens" )
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{cmdstanr}
\begin{frame}[fragile]{\texttt{cmdstanr}}

<<message=FALSE>>=
library( cmdstanr )
if (esegui) {
  cmdstanr::set_cmdstan_path("/home/cox/conda/bin/cmdstan/")
  writeLines( Scode, con = paste0(Sdir,"binomial.stan"))
  model_binomial <- cmdstan_model( paste0(Sdir,"binomial.stan") )
  save(fit_binomial.1, SEED, model_binomial, file = paste0(datadir,"STANfit.rda"))
}
@

<<echo=TRUE,eval=FALSE>>=
# carico il pacchetto
library( cmdstanr )
@
\pause
<<echo=TRUE,eval=FALSE>>=
# salvo il codice in un file esterno
writeLines( Scode, con = "binomial.stan" )
@

\pause
<<echo=TRUE,eval=FALSE>>=
# compilo il codice
model <- cmdstan_model( "binomial.stan" )
@
\pause

<<eval=FALSE,echo=TRUE>>=
# stima dei parametri
fit_binomial.2 <- model$sample(
  data = dataList,
  seed = 1,
  parallel_chains = parallel::detectCores()
)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{cmdstanr}}

\small
<<echo=TRUE,eval=FALSE>>=
fit_binomial.2$summary()
@

\pause
<<message=FALSE>>=
cmdstanr::set_cmdstan_path("/home/cox/conda/bin/cmdstan/")
fit_binomial.2 <- model_binomial$sample(
  data = dataList, seed = SEED, parallel_chains = parallel::detectCores(), refresh = 0
)
draws <- fit_binomial.2$draws()
@

<<results='markup'>>=
fit_binomial.2$summary()
@


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{cmdstanr}: \textbf{traceplot}}

\vspace{-.3cm}
<<echo=TRUE,eval=FALSE>>=
library( bayesplot )
draws <- fit_binomial.2$draws()
mcmc_trace( draws, pars = "theta" )
@
\pause
<<message=FALSE,fig.height=2.5,fig.width=4>>= 
library( bayesplot )
mcmc_trace( draws, pars = "theta" )
@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
mcmc_hist( draws, pars = "theta" )
@
\pause
<<message=FALSE,fig.height=2.5>>=
mcmc_hist( draws, pars = "theta" )
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
mcmc_dens( draws, pars = "theta" )
@
\pause
<<message=FALSE,fig.height=2.5>>=
mcmc_dens( draws, pars = "theta" )
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
mcmc_areas( draws, pars = "theta", prob = 0.8 )
@
\pause
<<message=FALSE,fig.height=2.5>>=
mcmc_areas( draws, pars = "theta", prob = 0.8 )
@

\end{frame}


%%%%%%%%%%%
\begin{frame}[fragile]%{\textbf{{Exercise}}}

\vspace{.3cm}
\begin{beamerboxesrounded}[upper=upesempio,lower=loesempio, shadow=true]
{\textbf{Exercise}}
\textbf{Proof that the obtained empirical posterior is a $\bm{B}( \mathbf{1+\Sexpr{sum(y)}, 1+\Sexpr{sum(y==0)}} )$}
\end{beamerboxesrounded}

\pause
<<results='markup',sanitize=TRUE>>=
cat("POST <- extract( fit_binomial.1, 'theta' )","\n") 
cat("plot( density( POST$theta ) )","\n")
cat(paste0("curve( dbeta( x, ",1+sum(y),", " ,1+sum(y==0)," ), add = TRUE, col = 'red' )"),"\n")
@

\pause
<<fig.height=2>>=
POST <- data.frame(extract( fit_binomial.1, "theta" )) 
ggplot(POST,aes(theta)) + theme_bw() + geom_density() + stat_function(fun = dbeta,args = list(shape1=1+sum(y),shape2=1+sum(y==0)), color = "red" ) + ylab("")
@


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%
\subsection[normal]{Inference with normal distribution}
\begin{frame}{Inference with normal distribution}

  \begin{itemize} \pause
   \item Perhaps the most useful (or extensively used) probability model for data analysis is the normal distribution: $$p(y|\mu,\sigma)=\frac{1}{Z} \mbox{exp}\left( -\frac{1}{2} \frac{(y-\mu)^2}{\sigma^2} \right)$$ where $Z=\sigma \sqrt{2\pi}$.
   \item The problem of inference involves estimating parameters $\mu$ and $\sigma$.
 \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Example}

<<results='hide'>>=
set.seed(20140618)
(Y <- round(rnorm(10,90,15)))
YS <- paste("$$y=\\{",paste(Y,collapse=", "),"\\}$$")
@

\begin{itemize}
\item Let's suppose to have assessed the cognitive functions of \Sexpr{length(Y)} patients with a test (e.g. QI with average 100 and sd 15), obtaining the following scores: \Sexpr{YS} 
 \item The sample mean score is $\overline{y}=\Sexpr{round(mean(Y),2)}$ (with $s=\Sexpr{round(sd(Y),2)}$).
 \item We want to estimate posterior distributions of $\mu$ and $\sigma$.
\end{itemize}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Graphical representation of the model}

\begin{columns}
\begin{column}{0.1\textwidth}
\end{column}
\begin{column}{0.3\textwidth}
%\centerline{\scalebox{1.5}{\input{img/LW401}}} 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{tikzpicture}[>=latex, scale = 1.1, every node/.style={scale=1.4}]

  % Define nodes
  \node[obs] (x) {$y_i$};
  \node[latent, above=of x, xshift=-.7cm] (mu) {$\mu$};
  \node[latent, above=of x, xshift=.7cm] (sigma) {$\sigma$};

  % Connect the nodes
  \edge {mu,sigma} {x} ; %
  \plate {x} {(x)} {$i$ data} ;

\end{tikzpicture} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\end{column}
\small \pause
\begin{column}{0.6\textwidth}  
  \begin{itemize}
   \item Graphical scheme of the model: \begin{itemize}
    \item $\mu \sim \mbox{Normal}(100,10)$
    \item $\sigma \sim \mbox{Uniform}(0,20)$
    \item $y_i \sim \mbox{Normal}(\mu,\sigma)$
     \end{itemize}  \pause
   \item The value assigned to the maximum of variance (in this case 20) must be choosen according to the problem. 
   \item In this case the wide spread of $\sigma$ value indicates a high level of uncertainty about this parameter. 
 \end{itemize}
  \end{column}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Example}}

<<>>=
normal_stancode <- "
  data {
    int N; // sample size
    vector[N] y; // data
  }
  parameters {
    real mu;
    real<lower=0, upper=20> sigma;
  }
  model {
    target += normal_lpdf( mu | 100, 10 ); // mu prior
    target += normal_lpdf( y | mu, sigma ); // likelihood
  }
  generated quantities {
    real ypred;
    ypred = normal_rng(mu, sigma);
  }
"
@

\vspace{-.5cm}
<<results='markup'>>=
L <- capture.output(cat(normal_stancode,"\n"))
fine <- grep("parameters",L)-1
for (j in 1:fine) cat(L[j],"\n")
@
\pause \vspace{-.6cm}
<<results='markup'>>=
ini <- fine+1
fine <- grep("model \\{",L)-1
for (j in ini:fine) cat(L[j],"\n")
@
\pause \vspace{-.6cm}
<<results='markup'>>=
ini <- fine+1
fine <- grep("generated",L)-1
for (j in ini:fine) cat(L[j],"\n")
@
\pause \vspace{-.6cm}
<<results='markup'>>=
ini <- fine+1
for (j in ini:length(L)) cat(L[j],"\n")
@

\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]

%\vspace{-.5cm}
<<echo=TRUE>>=
normal_stancode <- "
  data {
    int N; // sample size
    vector[N] y; // data
  }
  parameters {
    real mu;
    real<lower=0, upper=20> sigma;
  }
  model {
    target += normal_lpdf( mu | 100, 10 ); // mu prior
    target += normal_lpdf( y | mu, sigma ); // likelihood
  }
  generated quantities {
    real ypred;
    ypred = normal_rng(mu, sigma);
  }
"
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}}
<<echo=TRUE>>=
dataList <- list( y = c( 73, 101, 74, 76, 112, 71, 71,
    75, 97, 67 ), N = 10 )
@
\pause \vspace{-.7cm}
<<echo=TRUE,eval=FALSE>>=
fit_normal.1 <- stan( 
  model_code = normal_stancode, 
  data = dataList, 
  seed = 1, 
  cores = parallel::detectCores() 
)
@

<<>>=
if (esegui) {
  fit_normal.1 <- stan( model_code = normal_model, data = dataList, seed = SEED, cores = parallel::detectCores() )
  save(fit_binomial.1, model_binomial, fit_normal.1, SEED, file = paste0(datadir,"STANfit.rda"))
}
@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}}

<<echo=TRUE,eval=FALSE>>=
print( fit_normal.1, pars = c("mu","sigma") )
@
\pause \vspace{-.8cm}
<<results="markup",message=FALSE>>=
options(width=80)
L <- capture.output(fit_normal.1)

fine <- grep("post-warmup",L)+1
for (j in 1:fine) cat(L[j],"\n")

round(summary(fit_normal.1,probs = c(0.055, 0.945),pars=c("mu","sigma"))$summary,2)
ini <- grep("Samples",L)-1
for (j in ini:length(L)) cat(L[j],"\n")
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}:\textbf{traceplot}}

\vspace{-.3cm}
<<echo=TRUE,message=FALSE,eval=FALSE>>=
stan_trace( fit_normal.1, pars = c("mu","sigma"),
            inc_warmup = TRUE )
@
\pause 
<<fig.height=2.8,fig.width=4>>= 
stan_trace( fit_normal.1, pars = c("mu","sigma"), inc_warmup = TRUE )+theme(text=element_text(size=10))
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<echo=TRUE,message=FALSE,fig.keep="none">>=
plot( fit_normal.1, plotfun = "hist", 
      pars = c("mu","sigma") )
@
\pause
<<fig.width=4,fig.height=2.8,message=FALSE>>=
plot(fit_normal.1,plotfun="hist", pars = c("mu","sigma"))
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{posterior predictive check}}

\vspace{-.3cm} 
<<echo=TRUE,eval=FALSE>>=
y <- dataList$y
yrep <- matrix( 
  extract( fit_normal.1, pars = "ypred" )$ypred, 
  ncol = length( y ) )
ppc_dens_overlay( y, yrep[1:50,])
@
\pause
<<echo=FALSE,fig.width=4,fig.height=2>>=
TEXTSIZE <- 10
y <- dataList$y
yrep <- matrix( extract( fit_normal.1, pars = "ypred" )$ypred, ncol = length( y ) )

ppc_dens_overlay( y, yrep[1:50,]) + theme(text=element_text(size = TEXTSIZE))
@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Bivariate Posterior distribution\footnote{Figure is produced by the \texttt{stat\_density2d()} function (\texttt{ggplot2} package).}}

<<fig.width=4,fig.height=2.8>>=
OUT <- as.data.frame(fit_normal.1)
ggplot(OUT,aes(mu,sigma)) + theme_bw() + stat_density2d(geom="tile",aes(fill=after_stat(density)), contour=FALSE)+scale_alpha_continuous(limits=c(0,0.2),breaks=seq(0,0.2,by=0.025))+scale_fill_gradient(low="white", high="red")+xlab("$\\mu$")+ylab("$\\sigma$")+theme(text=element_text(size=12))

@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{cmdstanr}
\begin{frame}[fragile]{\texttt{cmdstanr}}

<<message=FALSE>>=

if (esegui) {
  cmdstanr::set_cmdstan_path("/home/cox/conda/bin/cmdstan/")
  writeLines( normal_stancode, con = paste0(Sdir,"normal.stan"))
  model_normal <- cmdstan_model( paste0(Sdir,"normal.stan") )
  save(fit_binomial.1, model_binomial, fit_normal.1, SEED, model_normal, file = paste0(datadir,"STANfit.rda"))
}
@

<<echo=TRUE,eval=FALSE>>=
# salvo il codice in un file esterno
writeLines( normal_stancode, con = "normal.stan" )
@

\pause
<<echo=TRUE,eval=FALSE>>=
# compilo il codice
model_normal <- cmdstan_model( "normal.stan" )
@
\pause

<<eval=FALSE,echo=TRUE>>=
# stima dei parametri
fit_normal.2 <- model_normal$sample(
  data = dataList,
  seed = 1,
  parallel_chains = parallel::detectCores()
)
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{cmdstanr}}

\small
<<echo=TRUE,eval=FALSE>>=
fit_normal.2$summary()
@

\pause
<<message=FALSE>>=
cmdstanr::set_cmdstan_path("/home/cox/conda/bin/cmdstan/")
fit_normal.2 <- model_normal$sample(
  data = dataList, seed = 1, refresh = 0,
  parallel_chains = parallel::detectCores()
)
draws <- fit_normal.2$draws()
yrep <- fit_normal.2$draws("ypred")
@

<<results='markup'>>=
fit_normal.2$summary()
@


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{cmdstanr}: \textbf{traceplot}}

\vspace{-.3cm}
<<echo=TRUE,eval=FALSE>>=
draws <- fit_normal.2$draws()
mcmc_trace( draws, pars = c("mu","sigma") )
@
\pause
<<message=FALSE,fig.height=2.5,fig.width=4>>= 
mcmc_trace( draws, pars = c("mu","sigma") ) + theme(text = element_text(size = TEXTSIZE))
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
mcmc_hist( draws, pars = c("mu","sigma") )
@
\pause
<<message=FALSE,fig.height=2.5>>=
mcmc_hist( draws, pars = c("mu","sigma") ) + theme(text = element_text(size = TEXTSIZE))
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
mcmc_dens( draws, pars = c("mu","sigma") )
@
\pause
<<message=FALSE,fig.height=2.5>>=
mcmc_dens( draws, pars = c("mu","sigma") ) + theme(text = element_text(size = TEXTSIZE))
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{rstan}: \textbf{plotting functions}}

<<eval=FALSE,echo=TRUE>>=
mcmc_areas( draws, pars = c("mu","sigma"), prob = 0.8 ) 
@
  
\pause
<<message=FALSE,fig.height=2.5>>=
mcmc_areas( draws, pars = c("mu","sigma"), prob = 0.8 ) + theme(text = element_text(size = TEXTSIZE))
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{cmdstanr}: \textbf{posterior predictive check}}

<<echo=TRUE,eval=FALSE>>=
yrep <- fit_normal.2$draws("ypred", format = "matrix")
yrep <- matrix( yrep, ncol = length( y ) )
ppc_dens_overlay( y, yrep[1:50,] )
@
\pause
<<echo=FALSE,fig.width=4,fig.height=2>>=
yrep <- fit_normal.2$draws("ypred", format = "matrix")
yrep <- matrix( yrep, ncol = length( y ) )
ppc_dens_overlay( y, yrep[1:50,] ) + theme(text=element_text(size = TEXTSIZE))
@

\end{frame}


%%%%%%%%%%%%
\section[STAN packages]{Packages for using STAN}

\begin{frame}[fragile]{\textbf{Packages for using STAN}}

\begin{itemize}
 \item \texttt{rstan}: It provides the $\mathrm{R}$ interface to Stan. The \texttt{rstan} package allows one to conveniently fit Stan models from $\mathrm{R}$ and access the output, including posterior inferences and intermediate quantities such as evaluations of the log posterior density and its gradients.
 
 \item \texttt{cmdstanr}: a lightweight interface to Stan for R users that provides an alternative to the traditional \texttt{rstan} interface. 

\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Packages for using STAN}}

\begin{itemize}
 \item \texttt{rethinking}: This package accompanies a book and course on Bayesian data analysis (by Richard McElreath), featured Quadratic approximate estimation through \texttt{quap()} and Hamiltonian Monte Carlo through \texttt{ulam()}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Example with \texttt{rethinking}: Quadratic approximate}}

\small
<<echo=TRUE,message=FALSE,warning=FALSE>>=
library( rethinking )
fit_quap <- quap(
  alist(
    y ~ dnorm( mu, sigma ),
    mu ~ dnorm( 100, 10 ),
    sigma ~ dunif( 0, 20 )
  ), data = dataList, start = list( mu = 90, sigma = 10))
@
\vspace{-.7cm} \pause
<<eval=FALSE,echo=TRUE>>=
precis( fit_quap )
@
\vspace{-.7cm} \pause
<<results='markup'>>=
rethinking::precis(fit_quap)
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Example with \texttt{rethinking}}}

\small
<<message=FALSE>>=
if (esegui) {
  library(rethinking)
  fit_ret <- ulam(
    alist(
      y ~ dnorm( mu, sigma ),
      mu ~ dnorm( 100, 10 ),
      sigma ~ dunif( 0, 20 )
    ),
    data = dataList, chains = 4, cores = 4, seed = SEED )
  save(fit_ret,SEED,file=paste0(datadir,"STANfit_rethinking.rda"))
}
load(paste0(datadir,"STANfit_rethinking.rda"))
@
<<echo=TRUE,eval=FALSE>>=
library( rethinking )
fit <- ulam(
    alist(
      y ~ dnorm( mu, sigma ),
      mu ~ dnorm( 100, 10 ),
      sigma ~ dunif( 0, 20 )
    ),
    data = dataList, chains = 4, cores = 4 )
@
\vspace{-.7cm} \pause
<<eval=FALSE,echo=TRUE>>=
precis( fit )
@
\vspace{-.7cm} \pause
<<results='markup'>>=
rethinking::precis(fit_ret)
@


\end{frame}
%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Packages for using STAN}}

\begin{itemize}
\item \texttt{rstanarm}: The goal of this package is to make Bayesian estimation routine for the most common regression models that applied researchers use. This will enable researchers to avoid the counter-intuitiveness of the frequentist approach to probability and statistics with only minimal changes to their existing $\mathrm{R}$scripts.

\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Example with \texttt{rstanarm}}}

<<message=FALSE>>=
library( rstanarm )
if (esegui) {
  d <- data.frame( y = dataList$y )
  fit_rstanarm <- stan_glm( y ~ 1, data = d, seed = SEED )
  save(fit_binomial.1, fit_normal.1, model_binomial, model_normal, fit_rstanarm, SEED, file = paste0(datadir,"STANfit.rda"))
}
@

\vspace{-.3cm}
<<echo=TRUE,results='hide',message=FALSE>>=
library( rstanarm )
d <- data.frame( y = dataList$y )
stan_glm( y ~ 1, data = d )
@
\vspace{-.3cm} \pause
<<results='markup'>>=
L <- capture.output(fit_rstanarm)
for (l in 1:(grep("sigma",L)+1)) cat(L[l],"\n")
@


\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Packages for using STAN}}

\begin{itemize}
  \item \texttt{brms}: Fit Bayesian generalized (non-)linear multivariate multilevel models using Stan for full Bayesian inference. A wide range of distributions and link functions are supported, allowing users to fit -- among others -- linear, robust linear, count data, survival, response times, ordinal, zero-inflated, hurdle, and even self-defined mixture models all in a multilevel context.
\end{itemize}


\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Example with \texttt{brms}}}

<<message=FALSE>>=
library(brms)
if (esegui) {
  fit_brms <- brm(y ~ 1, data = d, seed = SEED)
  save(fit_brms,SEED, file=paste0(datadir,"STANfit_brms.rda"))
}
load(paste0(datadir,"STANfit_brms.rda"))
@
<<eval=FALSE,echo=TRUE,size="footnotesize">>=
library( brms )
brm( y ~ 1, data = d )
@
\vspace{-.3cm} \pause
<<results='markup',warning=FALSE,size="footnotesize">>=
L <- capture.output(fit_brms)
for (l in 1:(grep("Draws w",L)-2)) cat(L[l],"\n")
@


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\textbf{Packages using STAN}}

\begin{itemize}
 \item \texttt{shinystan}: graphical user interface.
 \item \texttt{blavaan}: Fit a variety of Bayesian latent variable models, including confirmatory factor analysis, structural equation models, and latent growth curve models.
 \item \texttt{edstan}: Stan for item response theory, it attempts to make easy the fitting of standard item response theory models using rstan. 
 \item $\ldots$
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{For further information}

\textbf{BUGS}:
\begin{thebibliography}{1}
\begin{footnotesize}
\bibitem{} \url{http://bayesmodels.com/}
\bibitem{} \url{http://www.mrc-bsu.cam.ac.uk/software/bugs/the-bugs-project-bugs-resources-online/}
\end{footnotesize}
\end{thebibliography}

\vspace{.5cm}
\textbf{rjags}:
\begin{thebibliography}{1}
\begin{footnotesize}
\bibitem{} \url{http://www.johnmyleswhite.com/notebook/2010/08/20/using-jags-in-r-with-the-rjags-package/}
\end{footnotesize}
\end{thebibliography}

\vspace{.5cm}
\textbf{STAN}:
\begin{thebibliography}{1}
\begin{footnotesize}
\bibitem{} \url{http://mc-stan.org/}
\bibitem{} \url{https://www.mzes.uni-mannheim.de/socialsciencedatalab/article/applied-bayesian-statistics/}
\end{footnotesize}
\end{thebibliography}

\end{frame}

%\section{FINO QUI}
%%%%%%%%%%%%%%%%%%%% FINE DOCUMENTO
\section*{}
\begin{frame}[plain,fragile]{\textbf{Used R packages}}

<<results='markup',message=FALSE>>=
options(width = 80)
library(report)
SI <- report(sessionInfo())
PACK <- attr(SI,"table")$Package
REF <- attr(SI,"table")$Reference
REF <- gsub("#","", gsub("&","\\\\&",gsub("<","",gsub(">","",gsub("_","\\\\_",REF)))))

REF <- REF[!grepl("kandinsky",PACK)] 
#REF <- REF[!grepl("R Core Team",REF)]

PACK <- PACK[!grepl("kandinsky",PACK)]
@

\scriptsize
\begin{itemize}
<<results='asis'>>=

L <- gregexpr("\\).",REF) 
fine <- unlist(lapply(L, function(x){
  return(x[1]+1)
}))

for (k in 1:length(PACK)) {
  cat(paste0("\\item \\texttt{",PACK[k],"}. "))
  cat(substr(REF[k],1,fine[k]),"\n")
}
@
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[plain]
  \frametitle{}

\begin{flushright}
  \scalebox{.013}{\includegraphics{img/logo_psicostat.png}}
\end{flushright}


\vspace{1.5cm}
\begin{center}
\texttt{massimiliano.pastore@unipd.it}
\url{https://psicostat.dpss.psy.unipd.it/}
\end{center}

\vspace{1cm}
\begin{flushright}
  \scalebox{.25}{\includegraphics{img/loghi2017.png}}
\end{flushright}
\end{frame}

\end{document}
% +++++++++++++++++++++++
\section{FINO QUI}
<<>>=
# KUtils::pulizia(paste(main,"knitr/",sep=""), c(".Rnw",".bib"))
@
\end{document}

%%%%%%%%%%%%%%%%%%%%%%%% ALTRI PACKAGES
\section{ALTRI PACKAGES}




